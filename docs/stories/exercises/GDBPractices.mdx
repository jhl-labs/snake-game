import { Meta, Source } from '@storybook/blocks';
import { ExerciseCard } from '../../components/ExerciseCard';

<Meta title="Exercises/GDB 디버깅 실습" />

# GDB 디버깅 실습

C 프로그램의 일반적인 버그를 GDB로 디버깅하는 방법을 학습하는 실습입니다.

---

## 실습 개요

| 실습 | 버그 유형 | 핵심 학습 |
|------|-----------|-----------|
| Lab 1 | NULL 포인터 역참조 | `bt`, `print` - GDB 기초 |
| Lab 2 | 배열 범위 초과 | `watch`, `x/` - 메모리 감시 |
| Lab 3 | Use-After-Free | ASan 활용 |
| Lab 4 | 초기화되지 않은 변수 | `-Wall`, `info locals` |
| Lab 5 | 무한 재귀 | `bt 20`, `frame` - 콜스택 분석 |
| Lab 6 | Double Free | `break free` - 힙 문제 추적 |

---

## Lab 1: NULL 포인터 역참조

<ExerciseCard
  number={1}
  title="NULL 포인터 역참조"
  difficulty="초급"
  description="학생 성적 관리 시스템에서 Segmentation fault가 발생합니다. find_student()가 NULL을 반환했을 때 체크 없이 역참조하는 문제입니다."
  hint="set_score 함수에서 student 포인터가 NULL인지 확인하세요"
/>

### 증상

<Source
  language="text"
  code={`
$ ./buggy
학생 관리 시스템 시작
...
Segmentation fault (core dumped)
`}
/>

### 디버깅 방법

<Source
  language="bash"
  code={`
gcc -g -o buggy problem.c
gdb ./buggy

(gdb) run
(gdb) bt          # 백트레이스 확인
(gdb) bt full     # 지역 변수 포함
(gdb) print student  # NULL 확인
`}
/>

### 파일 위치

`practices/lab1-null-pointer/`

---

## Lab 2: 배열 범위 초과 (Buffer Overflow)

<ExerciseCard
  number={2}
  title="배열 범위 초과"
  difficulty="초급"
  description="장바구니 시스템에서 'stack smashing detected' 오류가 발생합니다. 배열 인덱스 검사 없이 접근하여 스택 메모리가 손상됩니다."
  hint="add_item 함수에서 index가 배열 범위(0-4) 내인지 확인하세요"
/>

### 증상

<Source
  language="text"
  code={`
$ ./buggy
장바구니 시스템 시작
...
*** stack smashing detected ***: terminated
Aborted (core dumped)
`}
/>

### 디버깅 방법

<Source
  language="bash"
  code={`
gcc -g -o buggy problem.c
gdb ./buggy

(gdb) break add_item
(gdb) run
(gdb) print index     # 잘못된 인덱스 확인
(gdb) x/20x &cart     # 메모리 레이아웃 확인
`}
/>

### 파일 위치

`practices/lab2-buffer-overflow/`

---

## Lab 3: Use-After-Free

<ExerciseCard
  number={3}
  title="Use-After-Free"
  difficulty="중급"
  description="free()로 해제한 메모리에 접근하는 버그입니다. 가비지 데이터 출력, 간헐적 크래시, 데이터 손상이 발생합니다."
  hint="remove_node 함수에서 free() 후 해제된 포인터를 반환하는지 확인하세요"
/>

### 증상

<Source
  language="text"
  code={`
- 가비지 데이터 출력
- 간헐적 크래시
- 데이터 손상
`}
/>

### 디버깅 방법

<Source
  language="bash"
  code={`
# AddressSanitizer 사용 (권장)
gcc -g -fsanitize=address -o buggy_asan problem.c
./buggy_asan

# GDB 사용
gdb ./buggy
(gdb) break remove_node
(gdb) run
(gdb) print *current   # free 전
(gdb) next
(gdb) print *current   # free 후 - 해제된 메모리
`}
/>

### 파일 위치

`practices/lab3-use-after-free/`

---

## Lab 4: 초기화되지 않은 변수

<ExerciseCard
  number={4}
  title="초기화되지 않은 변수"
  difficulty="중급"
  description="초기화되지 않은 변수로 인한 비결정적 동작입니다. 실행마다 다른 결과, 예상과 다른 계산 결과가 나타납니다."
  hint="init_stats에서 sum, average 초기화와 find_max에서 max 변수 초기화를 확인하세요"
/>

### 증상

<Source
  language="text"
  code={`
- 실행마다 다른 결과
- 예상과 다른 계산 결과
- 비결정적 동작
`}
/>

### 디버깅 방법

<Source
  language="bash"
  code={`
# 컴파일러 경고 활용
gcc -g -Wall -Wuninitialized -o buggy problem.c

# GDB 사용
gdb ./buggy
(gdb) break init_stats
(gdb) run
(gdb) finish
(gdb) print stats      # 초기화되지 않은 멤버 확인
(gdb) info locals
`}
/>

### 파일 위치

`practices/lab4-uninitialized/`

---

## Lab 5: 무한 재귀 (Stack Overflow)

<ExerciseCard
  number={5}
  title="무한 재귀"
  difficulty="중급"
  description="무한 재귀로 인한 스택 오버플로우입니다. count_nodes 함수에서 parent도 순회하여 순환 참조가 발생합니다."
  hint="count_nodes에서 parent 순회를 제거하세요 (left, right만 순회)"
/>

### 증상

<Source
  language="text"
  code={`
- Segmentation fault
- 스택 메모리 소진
- 프로그램 응답 없음 후 크래시
`}
/>

### 디버깅 방법

<Source
  language="bash"
  code={`
gcc -g -o buggy problem.c
gdb ./buggy

(gdb) run
(gdb) bt         # 반복되는 함수 호출 확인
(gdb) bt 20      # 최근 20개 프레임
(gdb) bt -20     # 가장 오래된 20개 프레임
(gdb) frame 100  # 특정 프레임으로 이동
`}
/>

### 파일 위치

`practices/lab5-stack-overflow/`

---

## Lab 6: Double Free

<ExerciseCard
  number={6}
  title="Double Free"
  difficulty="고급"
  description="같은 메모리를 두 번 해제하는 버그입니다. clear_buffer 함수에서 free() 후 포인터를 NULL로 설정하지 않아 발생합니다."
  hint="clear_buffer에서 free(buf->data) 후 buf->data = NULL을 추가하세요"
/>

### 증상

<Source
  language="text"
  code={`
- free(): double free detected
- 힙 손상
- 프로그램 abort
`}
/>

### 디버깅 방법

<Source
  language="bash"
  code={`
# AddressSanitizer 사용 (권장)
gcc -g -fsanitize=address -o buggy_asan problem.c
./buggy_asan

# GDB 사용
gdb ./buggy
(gdb) break free
(gdb) run
(gdb) bt          # 첫 번째 free
(gdb) continue
(gdb) bt          # 두 번째 free (같은 주소!)
`}
/>

### 파일 위치

`practices/lab6-double-free/`

---

## 권장 학습 순서

1. **Lab 1** - GDB 기본 사용법 (`bt`, `print`)
2. **Lab 4** - 컴파일러 경고 활용 (`-Wall`)
3. **Lab 2** - 메모리 레이아웃과 watchpoint
4. **Lab 5** - 콜 스택 분석 (`frame`, `up`, `down`)
5. **Lab 3** - AddressSanitizer 활용
6. **Lab 6** - 복합적인 메모리 문제

---

## 실습 방법

### 자동 실행

각 폴더에서 `debug.sh`를 실행하면 자동으로 디버깅됩니다:

<Source
  language="bash"
  code={`
cd practices/lab1-null-pointer
./debug.sh
`}
/>

### 수동 디버깅

<Source
  language="bash"
  code={`
cd practices/lab1-null-pointer
gcc -g -o buggy problem.c
gdb ./buggy
`}
/>

---

## GDB 명령어 요약

| 명령어 | 설명 |
|--------|------|
| `run` | 프로그램 실행 |
| `bt` | 백트레이스 (콜 스택) |
| `bt full` | 지역 변수 포함 백트레이스 |
| `print VAR` | 변수 값 출력 |
| `print &VAR` | 변수 주소 출력 |
| `break FUNC` | 함수에 브레이크포인트 |
| `next` | 한 줄 실행 (step over) |
| `step` | 한 줄 실행 (step into) |
| `watch VAR` | 변수 변경 감시 |
| `frame N` | N번 프레임으로 이동 |
| `info locals` | 현재 프레임 지역 변수 |
| `x/Nx ADDR` | 메모리 N개 16진수 출력 |
| `continue` | 다음 브레이크포인트까지 실행 |
